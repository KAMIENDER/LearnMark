# 线程与进程

### 线程切换与进程切换

两者切换最大的区别在于：进程切换涉及到虚拟内存空间的切换而线程切换不会

* 虚拟内存是操作系统的一种抽象
* 虚拟内存作为一种资源存在，每个进程有自己的、私有的、地址连续的虚拟内存
  * 虚拟内存与实际的物理内存存在转换关系（地址空间映射），通过页表来实现，记录了虚拟内存到物理内存的映射关系
  * 页表查找通常是一个很慢的过程，通过cache的方式（TLB）进行加速
  * 进程切换之后TLB失效，因此切换后的一段时间内，进程执行的速度会下降，因此线程切换会比进程切换要快
* 进程拥有自己独立的虚拟内存地址空间，进程内线程共享进程的虚拟地址空间

进程线程进行切换的时候，其他上下文都需要进行切换

* 通用目的寄存器
* 浮点寄存器
* 程序计数器
* 用户栈
* 状态寄存器
* 内核栈
* 内核数据结构：如页表、进程表、文件表

这些上下文信息一般存储在PCB（进程控制块）、TCB（线程控制块），在不同操作系统中可能有着不一样的实现

* Linux操作系统中PCB、TCB为task_struct结构定义的数据结构

通过管理PCB、TCB的方式进行线程、进程的调度



### 线程间通信

进程间通信（IPC）

#### 线程间通信

##### 线程中的信息存储

* 局部数据

在操作系统中存在TLS，即线程局部存储，可以存储线程自己的变量信息。

```
在实现上，该全局变量给每一个线程都提供了一个副本，每一个线程的副本独立存在。如果进程中的TLS标志位被设置成INUSE，那么会给每一个线程分配一个数组，并且将线程和数组关联起来，后续的变量会存储在这个数组中，该数组有着大小限制
```

在不同的平台有着不一样的实现

尽量使用栈的方式进行参数的传递，而不是通过全局变量的方式（进线程切换都会切换自己的栈）

* 全局数据

共享进程内部的数据资源



##### 同步与互斥

多线程的情况下，可能会出现一些全局资源的访问、操作

* 互斥是指临界区资源某一时刻只能有一个线程进行访问、操作

多线程并发问题：如果不实现互斥会出现对临界区资源进行争用导致出现数据不一致、数据结果不正确

线程安全：一个函数通过某些线程通信手段保证线程之间不会出现并发问题，那么这个函数是线程安全的

线程安全的实现：

* 采用线程局部数据

* 原子操作

  * TSL，测试并加锁
  * XCHG，交换两个操作数

* 锁机制（实现机制，都是在原子操作基础上实现）

  * 管程
  * 信号量
  * 互斥量
  * https://www.cnblogs.com/binarylei/p/12544002.html

* 线程间通信

  

* 同步是指操作之间具有先后顺序依赖关系

同步实现：

利用每一步中的互斥关系来保证线程间同步



##### 通信

目的：

* 共享信息，某一些资源是全局的，通过这些资源实现某些功能

* 线程互斥与同步

方式：

* 锁机制
  * 互斥锁，保证只有一个线程访问资源，其他线程被挂起
  * 读写锁，读读共享，读写、写写互斥
  * 条件变量
    * 主要涉及到两个过程，a线程进行条件的判断，b线程对条件变量进行改动。
    * 访问条件变量（临界资源）需要上锁
    * 在调用pthread_cond_wait()的时候会对临界资源的互斥锁解锁，然后等待，为了防止在等待之前，b线程就发送了信号导致信号丢失，在wait之前需要上锁
    * 参考：https://www.jianshu.com/p/01ad36b91d39
  * 自旋锁，不会将对应线程阻塞，而是让其不断尝试获取锁，CPU代价比较高
* 信号量机制
  * 和互斥量相比，表示资源的总数，同样也会进行线程的挂起与唤醒操作
  * 无名信号量
  * 有名信号量
* 信号机制
  * 详细过程：https://zhuanlan.zhihu.com/p/78653866

