# C与C++

c++的新功能：模板、面向对象

### inline与defind区别

inline是声明内联函数，在编译的时候会直接把调用该函数的地方直接编译替换掉 ，避免频繁使用栈

defind声明的变量在使用的地方相当于字符串替换



### new、delete、malloc、free

new、delete、free：

* free，只是会进行内存的操作，即释放内存。new会调用构造函数，delete会调用析构函数

* new、delete是c++运算符，会执行对应的构造与析构函数
* malloc、free为库函数，只涉及内存的分配问题

构造函数调用顺序：基类-》子类

析构函数调用顺序：子类-》基类



### 多态、虚函数、纯虚函数

参考：https://zhuanlan.zhihu.com/p/41309205

* 虚函数：声明时前面加virtual，子类可以（或不）进行overwrite
* 纯虚函数：虚函数声明时在结尾加上=0，子类一定要进行overwrite
* 子类和父类都实现某个相同的成员函数的时候，默认调用的是父类的成员函数
* 多态，调用的虚函数取决于指针对象指向的类型，即使向下类型转换后也是一样
* 析构函数最好在基类中声明为虚函数，否则在进行析构的时候只会调用基类的析构函数

函数、虚表是放在一个全局的代码区，为类公有

成员变量、虚表指针是在堆区，属于每一个对象，因此

```c++
int main() 
{
    B bObject;
    A *p = & bObject;
}
```

时，p对象的虚表指针指向的是b的虚表，如果在函数调用中使用这种机制，只有在运行时才能够知道当前对象是什么类，在运行时进行的动态绑定



### epoll

https://zhuanlan.zhihu.com/p/64746509



### 智能指针

https://www.zhihu.com/question/319277442/answer/1517987598

传统指针在堆上分配内存使用之后，整个的生命周期就交给了用户，需要用户在恰当的时候进行内存的释放

智能指针为用户提供了自动销毁机制

使用计数的方式来判断释放的时机，当计数为时进行资源的释放

#### 基础

* 为一个模板类，同时具有指针的基本功能
* 目的是管理堆对象，那些不能够自己释放资源的对象

#### 类别

* auto_ptr

在拷贝、赋值构造的时候，进行对象的传递，原来的智能指针变成null

* unique_ptr

有唯一拥有权，计数永远为1

禁止了复制、赋值语义

使用move函数将一个对象的堆内容转给另外一个

可以指定析构内容，默认是调用对象的析构函数，在初始化指针的时候可以传对应的释放规则进去

* share_ptr

多个智能指针之间可以共享对象，相应的共享的时候，计数值会+1，每个指向该对象的指针析构的时候，计数-1，最后一个对象析构的时候会全部释放

跳出作用域的时候会进行相关对象的析构

赋值、初始化使用到的对象会对应的+1计数

enable_shared_from_this可能会造成循环引用的情况，它会返回一个share_ptr

* weak_ptr

weak_ptr不控制对象的生命周期

不会引起计数器的变化

可以由weak_ptr以及share_ptr进行初始化

不具有普通指针的访问操作功能



### stack overflow

堆栈溢出，在进行递归调用的时候，函数内部的局部变量会一直保存直到这个过程结束



### static

* 隐藏多个文件里面声明的变量，变为非全局变量，只有当前文件可见
* 修饰局部变量的时候，该局部变量只初始化一次，默认值为0，分配在全局数据区



### STL

* vector：底层为数组
* list：底层为链表
* map：红黑树，
* unordered_map：hash table

实现



### 模板

https://www.zhihu.com/question/309183344/answer/576192093

